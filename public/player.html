<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Spieler · 100 Leute gefragt</title>
  <link rel="stylesheet" href="/style.css" />
  <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
</head>
<body>
<div class="container">
  <div class="header">
    <h1 class="h">Spieler-Panel</h1>
    <div id="me" class="badge"></div>
  </div>

  <div class="card" style="margin-bottom:12px">
    <div class="small">Beitritt</div>
    <div class="controls">
      <input id="inName" class="input" placeholder="Dein Name" />
      <select id="inTeam" class="input">
        <option value="A">Team Rot</option>
        <option value="B">Team Blau</option>
      </select>
      <button class="btn ok" id="btnJoin">Beitreten</button>
    </div>
  </div>

  <!-- Turn-Hinweis -->
  <div id="turnBanner" class="notice" style="display:none; margin-bottom:12px;">
    Teaminfo lädt…
  </div>

  <div class="row">
    <!-- Ansicht 1: Brett -->
    <div id="viewBoard" class="card" style="flex:2">
      <h2 class="h">Brett</h2>
      <div id="board" class="board"></div>
      <div class="small" id="info">
        Wähle ein Feld, wenn dein Team am Zug ist. <b>Antworten bitte mündlich auf Discord</b> – der Admin deckt die Lösungen auf.
      </div>
      <div id="toast" class="notice hidden" style="margin-top:10px;"></div>
    </div>

    <!-- Ansicht 2: Aktive Runde (nur die gewählte Kategorie/Frage) -->
    <div id="viewRound" class="card hidden" style="flex:2">
      <h2 class="h">Aktive Runde</h2>
      <div class="small" id="roundMeta"></div>
      <h3 id="roundTitle" style="margin:6px 0 4px"></h3>
      <p id="roundQ" style="margin:0 0 10px"></p>
      <div id="roundList" class="list"></div>
      <div class="small" style="margin-top:10px">
        Antworten bitte im Sprachchat/Discord sagen. Der Admin deckt Lösungen live auf.
      </div>
    </div>

    <!-- Rechte Spalte: Team & Chat -->
    <div class="card" style="flex:1">
      <h2 class="h">Team</h2>
      <div id="players" class="list"></div>

      <h2 class="h" style="margin-top:10px">Team-Chat</h2>
      <div id="chatLog" class="list" style="max-height:220px; overflow:auto"></div>
      <div class="controls">
        <input id="chatIn" class="input" placeholder="Nur dein Team sieht das (Admin sieht alles)" />
        <button class="btn" id="chatBtn">Senden</button>
      </div>
    </div>
  </div>
</div>

<!-- Audios: auf 'none', Server liefert Fallback falls MP3 fehlt -->
<audio id="sfxCorrect" src="/sfx/correct.mp3" preload="none"></audio>
<audio id="sfxWrong"   src="/sfx/wrong.mp3"   preload="none"></audio>

<script>
const socket = io();

let me = { id:null, name:null, team:null };
let boardCache = null;
let currentTurnTeam = null;
let activeRound = null; // {ci, ii, points, turnTeam, question}

// Helpers
function el(t, attrs={}, ...children){
  const e=document.createElement(t);
  Object.entries(attrs).forEach(([k,v])=> e.setAttribute(k,v));
  children.forEach(c=> e.appendChild(typeof c==='string' ? document.createTextNode(c) : c));
  return e;
}
function showToast(msg, ms=3500){
  const t = document.getElementById('toast');
  t.textContent = msg;
  t.classList.remove('hidden');
  setTimeout(()=> t.classList.add('hidden'), ms);
}
function show(id){ document.getElementById(id).classList.remove('hidden'); }
function hide(id){ document.getElementById(id).classList.add('hidden'); }

// Join
document.getElementById('btnJoin').onclick = () => {
  const name = document.getElementById('inName').value.trim();
  const team = document.getElementById('inTeam').value;
  socket.emit('role:player');
  socket.emit('player:join', { name, team });
};

socket.on('welcome', (p) => {
  me = p;
  document.getElementById('me').textContent = `${p.name} · Team ${p.team}`;
  updateTurnBanner(currentTurnTeam);
});

// Spieler-Liste
function renderPlayers(players){
  const wrap = document.getElementById('players');
  wrap.innerHTML = '';
  players.forEach(p=>{
    const row = el('div', {class:'player ' + (p.team==='A'?'teamA':'teamB')},
      el('div', {}, `${p.name} (Team ${p.team})`),
      el('div', {}, `${p.score} P`)
    );
    wrap.appendChild(row);
  });
}

// Brett
const boardDiv = document.getElementById('board');
function renderBoard(board){
  boardCache = board;
  boardDiv.innerHTML = '';

  const myTurn = (me.team && currentTurnTeam && me.team === currentTurnTeam);
  boardDiv.classList.toggle('disabled', !myTurn);

  board.categories.forEach((cat, ci) => {
    const col = el('div', {});
    col.appendChild(el('div', {class:'cat'}, cat.name));
    const tiles = el('div', {class:'tiles'});

    cat.items.forEach((it, ii) => {
      const d = el('div', {class:'tile' + (it.answered ? ' used' : '')}, String(it.points));
      d.onclick = () => {
        if (it.answered) return;
        if (!(me.team && currentTurnTeam && me.team === currentTurnTeam)) return; // nur Team am Zug
        socket.emit('player:pickTile', { catIndex:ci, itemIndex:ii });
      };
      tiles.appendChild(d);
    });

    col.appendChild(tiles);
    boardDiv.appendChild(col);
  });
}

// Turn-Banner + Body-Theme
const turnBanner = document.getElementById('turnBanner');
function updateTurnBanner(team, reason=''){
  currentTurnTeam = team;

  document.body.classList.remove('turnA','turnB');

  if (!team){
    turnBanner.style.display='none';
    boardDiv.classList.add('disabled'); // bis Auslosung blocken
    return;
  }

  document.body.classList.add(team==='A' ? 'turnA' : 'turnB');
  turnBanner.style.display = 'block';
  const name = team === 'A' ? 'Team Rot' : 'Team Blau';
  turnBanner.textContent = `${name} ist am Zug. ${reason}`.trim();

  // Board interaktiv nur für Team am Zug
  const myTurn = (me.team && currentTurnTeam && me.team === currentTurnTeam);
  boardDiv.classList.toggle('disabled', !myTurn);
}

// Runden-Ansicht
const roundMeta  = document.getElementById('roundMeta');
const roundTitle = document.getElementById('roundTitle');
const roundQ     = document.getElementById('roundQ');
const roundList  = document.getElementById('roundList');

function showRoundView(p){
  // p: { catIndex,itemIndex, question, points, turnTeam }
  activeRound = { ci:p.catIndex, ii:p.itemIndex, points:p.points, turnTeam:p.turnTeam, question:p.question };

  roundMeta.textContent  = `Team ${p.turnTeam} beginnt • ${p.points} Punkte`;
  roundTitle.textContent = `Kategorie läuft`;
  roundQ.textContent     = p.question;

  // 5 leere Slots bauen (unabhängig vom Board-Cache)
  roundList.innerHTML = '';
  for (let i=0;i<5;i++){
    const row = el('div', {class:'answer-row', id:`ans-${i}`},
      el('div', {}, `${i+1}. —`),
      el('div', {}, `—%`)
    );
    roundList.appendChild(row);
  }

  // UI umschalten: Brett aus, Rundenansicht an
  hide('viewBoard');
  show('viewRound');
}

function hideRoundView(){
  activeRound = null;
  hide('viewRound');
  show('viewBoard');
}

// State-Updates
socket.on('board:init', (b)=>{ renderBoard(b); hideRoundView(); });
socket.on('state:update', data => {
  renderBoard(data.board);
  renderPlayers(data.players);

  // Falls wir eine Runde anzeigen, aber Feld ist bereits beendet → zurück ins Brett
  if (activeRound){
    const it = data.board.categories?.[activeRound.ci]?.items?.[activeRound.ii];
    if (!it || it.answered){
      hideRoundView();
    }
  }
});

// Globaler Start-Zug (nach Auslosung oder „Nächste Runde“)
socket.on('turn:global', (p) => {
  updateTurnBanner(p.team, 'Wählt ein Feld.');
  hideRoundView();
});

// Turnover innerhalb der Runde (Ansicht bleibt)
socket.on('turn:changed', (p) => {
  updateTurnBanner(p.turnTeam, 'Euer Zug!');
});

// Feld gestartet → komplette Rundenansicht zeigen (kein Popup)
socket.on('tile:revealed', p => {
  showRoundView(p);
  showToast(`Feld gestartet: ${p.points} Punkte – Team ${p.turnTeam} beginnt`, 2500);
});

// Antwort wurde (vom Admin) aufgedeckt → Slot füllen
socket.on('answer:revealed', p => {
  if (!activeRound || activeRound.ci!==p.catIndex || activeRound.ii!==p.itemIndex) return;
  document.getElementById('sfxCorrect').play().catch(()=>{});
  const row = document.getElementById(`ans-${p.index}`);
  if (!row) return;
  row.classList.add('revealed');
  row.firstChild.textContent = `${p.index+1}. ${p.text}`;
  row.lastChild.textContent  = `${p.percent}%`;
});

// Falschantwort-Sound
socket.on('guess:wrong', () => {
  document.getElementById('sfxWrong').play().catch(()=>{});
});

// Hinweis ans wartende Team: beraten (non-blocking)
socket.on('team:prepare', () => {
  showToast('Ihr dürft euch beraten! Gleich seid ihr am Zug.', 5000);
});

// Feld beendet → zurück zum Brett (Feld erscheint dort als „used“)
socket.on('tile:closed', p => {
  hideRoundView();
  showToast(`Feld beendet – Punkte an Team ${p.winnerTeam}`, 2500);
});

// Team-Chat
const chatLog = document.getElementById('chatLog');
const chatIn  = document.getElementById('chatIn');
document.getElementById('chatBtn').onclick = () => {
  const msg = chatIn.value.trim(); if (!msg) return;
  socket.emit('chat:team', { msg });
  chatIn.value = '';
};
socket.on('chat:team', m => {
  const row = el('div', {class:'player ' + (m.from.team==='A'?'teamA':'teamB')},
    el('div', {}, `${m.from.name}:`),
    el('div', {}, m.msg)
  );
  chatLog.appendChild(row);
  chatLog.scrollTop = chatLog.scrollHeight;
});
</script>
</body>
</html>
