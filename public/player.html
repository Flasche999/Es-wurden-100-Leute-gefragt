<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Spieler · 100 Leute gefragt</title>
  <link rel="stylesheet" href="/style.css" />
  <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>

  <!-- Kleinere Zusatz-Styles nur für die Spieler-Seite -->
  <style>
    /* Board für Nicht-Zug deaktivieren */
    .board.disabled .tile{ pointer-events:none; filter:saturate(.7) opacity(.6); }

    /* Celebration Overlay */
    #celebrateOverlay{
      position:fixed; inset:0; display:none; pointer-events:none;
      background:rgba(5,7,12,.35);
      z-index:9999;
    }
    #celebrateOverlay.show{ display:block; animation:fadeIn .2s ease; }
    @keyframes fadeIn { from{opacity:0} to{opacity:1} }

    .cele-wrap{
      position:absolute; inset:0; display:flex; align-items:center; justify-content:center; flex-direction:column;
    }
    .cele-text{
      font-size:42px; font-weight:800; letter-spacing:.5px; text-align:center;
      text-shadow:0 6px 24px rgba(0,0,0,.45);
      margin-top:16px;
    }
    .cele-text small{ display:block; font-weight:600; opacity:.85; font-size:16px; margin-top:6px; }
    .crown{
      font-size:96px; line-height:1; filter:drop-shadow(0 8px 24px rgba(0,0,0,.4));
      transform:translateY(0); animation:bounce 1.4s ease-in-out infinite;
    }
    @keyframes bounce{
      0%,100%{ transform:translateY(0) }
      50%{ transform:translateY(-8px) }
    }

    /* Confetti */
    .confetti{
      position:absolute; top:-10px; width:8px; height:14px; opacity:.9;
      animation:fall linear forwards, spin ease-in-out infinite;
      border-radius:2px;
    }
    @keyframes fall{
      to{ transform:translateY(110vh) rotate(360deg); opacity:1; }
    }
    @keyframes spin{
      0%{ transform:rotate(0deg) }
      50%{ transform:rotate(180deg) }
      100%{ transform:rotate(360deg) }
    }

    /* ===== Mini-Musik-Controls (Floating) ===== */
    #musicCtl{
      position:fixed; right:14px; bottom:14px; z-index:9000;
      display:flex; align-items:center; gap:8px; padding:8px 10px;
      background:rgba(10,16,32,.7); border:1px solid #22345a; border-radius:12px;
      backdrop-filter:blur(3px) saturate(1.1);
    }
    #musicCtl button{ min-width:100px }
    #bgmVol{ width:140px; accent-color:#00e0ff; }
  </style>
</head>
<body>
<div class="container">
  <div class="header">
    <h1 class="h">Spieler-Panel</h1>
    <div id="me" class="badge"></div>
  </div>

  <div class="card" style="margin-bottom:12px">
    <div class="small">Beitritt</div>
    <div class="controls">
      <input id="inName" class="input" placeholder="Dein Name" />
      <select id="inTeam" class="input">
        <option value="A">Team Rot</option>
        <option value="B">Team Blau</option>
      </select>
      <button class="btn ok" id="btnJoin">Beitreten</button>
    </div>
  </div>

  <!-- Turn-Hinweis -->
  <div id="turnBanner" class="notice" style="display:none; margin-bottom:12px;">
    Teaminfo lädt…
  </div>

  <div class="row">
    <!-- Ansicht 1: Brett -->
    <div id="viewBoard" class="card" style="flex:2">
      <h2 class="h">Brett</h2>
      <div id="board" class="board"></div>
      <div class="small" id="info">
        Wähle ein Feld, wenn dein Team am Zug ist. <b>Antworten bitte mündlich auf Discord</b> – der Admin deckt die Lösungen auf.
      </div>
      <div id="toast" class="notice hidden" style="margin-top:10px;"></div>
    </div>

    <!-- Ansicht 2: Aktive Runde (nur die gewählte Kategorie/Frage) -->
    <div id="viewRound" class="card hidden" style="flex:2">
      <h2 class="h">Aktive Runde</h2>
      <div class="small" id="roundMeta"></div>
      <h3 id="roundTitle" style="margin:6px 0 4px"></h3>
      <p id="roundQ" style="margin:0 0 10px"></p>
      <div id="roundList" class="list"></div>
      <div class="small" style="margin-top:10px">
        Antworten bitte im Sprachchat/Discord sagen. Der Admin deckt Lösungen live auf.
      </div>
    </div>

    <!-- Rechte Spalte: Team & Chat -->
    <div class="card" style="flex:1">
      <h2 class="h">Team</h2>
      <div id="players" class="list"></div>

      <h2 class="h" style="margin-top:10px">Team-Chat</h2>
      <div id="chatLog" class="list" style="max-height:220px; overflow:auto"></div>
      <div class="controls">
        <input id="chatIn" class="input" placeholder="Nur dein Team sieht das (Admin sieht alles)" />
        <button class="btn" id="chatBtn">Senden</button>
      </div>
    </div>
  </div>
</div>

<!-- Celebration Overlay -->
<div id="celebrateOverlay" aria-hidden="true">
  <div class="cele-wrap">
    <div class="crown" id="celeCrown">👑</div>
    <div class="cele-text" id="celeText">Team gewinnt!
      <small>Tippe/Klicke zum Ausblenden</small>
    </div>
  </div>
</div>

<!-- Audios: auf 'none', Server liefert Fallback falls MP3 fehlt -->
<audio id="sfxCorrect" src="/sfx/correct.mp3" preload="none"></audio>
<audio id="sfxWrong"   src="/sfx/wrong.mp3"   preload="none"></audio>
<!-- NEU: Select/Lock-in-Sound bei Feldwahl -->
<audio id="sfxSelect"  src="/sfx/select.mp3"  preload="none"></audio>

<!-- NEU: Hintergrundmusik (läuft bei allen, mit User-Geste starten) -->
<audio id="bgm" src="/music/bgm.mp3" preload="none" loop playsinline></audio>

<!-- NEU: Mini-Musik-Controls (floating) -->
<div id="musicCtl" class="card" style="padding:8px 10px;">
  <button class="btn" id="btnMusic">Musik ▶︎</button>
  <input id="bgmVol" type="range" min="0" max="1" step="0.01" title="Lautstärke">
</div>

<script>
const socket = io();

let me = { id:null, name:null, team:null };
let boardCache = null;
let currentTurnTeam = null;
let activeRound = null; // {ci, ii, points, turnTeam, question}

// Helpers
function el(t, attrs={}, ...children){
  const e=document.createElement(t);
  Object.entries(attrs).forEach(([k,v])=> e.setAttribute(k,v));
  children.forEach(c=> e.appendChild(typeof c==='string' ? document.createTextNode(c) : c));
  return e;
}
function showToast(msg, ms=3500){
  const t = document.getElementById('toast');
  t.textContent = msg;
  t.classList.remove('hidden');
  setTimeout(()=> t.classList.add('hidden'), ms);
}
function show(id){ document.getElementById(id).classList.remove('hidden'); }
function hide(id){ document.getElementById(id).classList.add('hidden'); }

// ===== Hintergrundmusik =====
const bgm     = document.getElementById('bgm');
const btnMus  = document.getElementById('btnMusic');
const volSl   = document.getElementById('bgmVol');

function updateMusicBtn(){
  btnMus.textContent = bgm.paused ? 'Musik ▶︎' : 'Musik ⏸';
}
function tryPlayBgm(){
  if (!bgm) return;
  bgm.play().then(updateMusicBtn).catch(()=>{/* Autoplay blockiert bis User-Geste */});
}
function initBgm(){
  const savedVol = parseFloat(localStorage.getItem('bgmVol') ?? '0.35');
  const vol = isFinite(savedVol) ? Math.min(1, Math.max(0, savedVol)) : 0.35;
  bgm.volume = vol;
  volSl.value = String(vol);

  updateMusicBtn();

  // Erst auf User-Geste starten (Autoplay-Policy)
  const startOnce = () => { tryPlayBgm(); document.removeEventListener('pointerdown', startOnce); };
  document.addEventListener('pointerdown', startOnce, { once:true });

  // Falls Tab wieder fokussiert → weiter spielen
  document.addEventListener('visibilitychange', () => {
    if (document.visibilityState === 'visible' && !bgm.paused) tryPlayBgm();
  });
}
btnMus.onclick = () => {
  if (bgm.paused){ tryPlayBgm(); }
  else { bgm.pause(); updateMusicBtn(); }
};
volSl.oninput = (e) => {
  const v = parseFloat(e.target.value || '0.35');
  bgm.volume = v;
  localStorage.setItem('bgmVol', String(v));
};
initBgm();

// Celebration helpers
const overlay = document.getElementById('celebrateOverlay');
const celeText = document.getElementById('celeText');
function makeConfetti(team='A', count=120){
  // remove old confetti
  document.querySelectorAll('#celebrateOverlay .confetti').forEach(n=>n.remove());
  const colors = team==='A'
    ? ['#ff4d6d','#ffd166','#ff7aa2','#ffe08a']
    : ['#4da3ff','#9be7ff','#a5f3fc','#c7d2fe'];
  for(let i=0;i<count;i++){
    const d = document.createElement('div');
    d.className = 'confetti';
    d.style.left = Math.random()*100 + 'vw';
    d.style.background = colors[Math.floor(Math.random()*colors.length)];
    const dur = 2.5 + Math.random()*2.5; // 2.5-5s
    const delay = Math.random()*0.8;     // 0-0.8s
    d.style.animationDuration = `${dur}s, ${0.6 + Math.random()*0.6}s`;
    d.style.animationDelay = `${delay}s, 0s`;
    d.style.transform = `translateY(-10px) rotate(${Math.random()*180}deg)`;
    overlay.appendChild(d);
  }
}
function celebrate(team){
  const name = team==='A' ? 'Team Rot' : 'Team Blau';
  celeText.innerHTML = `${name} gewinnt!<small>Tippe/Klicke zum Ausblenden</small>`;
  document.getElementById('celeCrown').style.color = team==='A' ? 'var(--red)' : 'var(--blue)';
  makeConfetti(team, 150);
  overlay.classList.add('show');
  // kleiner Soundfeedback
  document.getElementById('sfxCorrect').play().catch(()=>{});
  // auto hide nach 6.5s
  clearTimeout(window.__cele_to);
  window.__cele_to = setTimeout(()=> overlay.classList.remove('show'), 6500);
}
overlay.addEventListener('click', ()=> overlay.classList.remove('show'));
overlay.addEventListener('touchstart', ()=> overlay.classList.remove('show'));

// Join
document.getElementById('btnJoin').onclick = () => {
  const name = document.getElementById('inName').value.trim();
  const team = document.getElementById('inTeam').value;
  socket.emit('role:player');
  socket.emit('player:join', { name, team });
};

socket.on('welcome', (p) => {
  me = p;
  document.getElementById('me').textContent = `${p.name} · Team ${p.team}`;
  updateTurnBanner(currentTurnTeam);
});

// Spieler-Liste
function renderPlayers(players){
  const wrap = document.getElementById('players');
  wrap.innerHTML = '';
  players.forEach(p=>{
    const row = el('div', {class:'player ' + (p.team==='A'?'teamA':'teamB')},
      el('div', {}, `${p.name} (Team ${p.team})`),
      el('div', {}, `${p.score} P`)
    );
    wrap.appendChild(row);
  });
}

// Brett
const boardDiv = document.getElementById('board');
function renderBoard(board){
  boardCache = board;
  boardDiv.innerHTML = '';

  const myTurn = (me.team && currentTurnTeam && me.team === currentTurnTeam);
  boardDiv.classList.toggle('disabled', !myTurn);

  board.categories.forEach((cat, ci) => {
    const col = el('div', {});
    col.appendChild(el('div', {class:'cat'}, cat.name));
    const tiles = el('div', {class:'tiles'});

    cat.items.forEach((it, ii) => {
      const d = el('div', {class:'tile' + (it.answered ? ' used' : '')}, String(it.points));
      d.onclick = () => {
        if (it.answered) return;
        if (!(me.team && currentTurnTeam && me.team === currentTurnTeam)) return; // nur Team am Zug
        socket.emit('player:pickTile', { catIndex:ci, itemIndex:ii });
      };
      tiles.appendChild(d);
    });

    col.appendChild(tiles);
    boardDiv.appendChild(col);
  });
}

// Turn-Banner + Body-Theme
const turnBanner = document.getElementById('turnBanner');
function updateTurnBanner(team, reason=''){
  currentTurnTeam = team;

  document.body.classList.remove('turnA','turnB');

  if (!team){
    turnBanner.style.display='none';
    boardDiv.classList.add('disabled'); // bis Auslosung blocken
    return;
  }

  document.body.classList.add(team==='A' ? 'turnA' : 'turnB');
  turnBanner.style.display = 'block';
  const name = team === 'A' ? 'Team Rot' : 'Team Blau';
  turnBanner.textContent = `${name} ist am Zug. ${reason}`.trim();

  // Board interaktiv nur für Team am Zug
  const myTurn = (me.team && currentTurnTeam && me.team === currentTurnTeam);
  boardDiv.classList.toggle('disabled', !myTurn);
}

// Runden-Ansicht
const roundMeta  = document.getElementById('roundMeta');
const roundTitle = document.getElementById('roundTitle');
const roundQ     = document.getElementById('roundQ');
const roundList  = document.getElementById('roundList');

function showRoundView(p){
  // p: { catIndex,itemIndex, question, points, turnTeam }
  activeRound = { ci:p.catIndex, ii:p.itemIndex, points:p.points, turnTeam:p.turnTeam, question:p.question };

  // Hinweis: Label 1..5 statt Punktezahl
  roundMeta.textContent  = `Am Zug: Team ${p.turnTeam} • Feld ${p.points}`;
  roundTitle.textContent = `Kategorie läuft`;
  roundQ.textContent     = p.question;

  // 5 leere Slots bauen
  roundList.innerHTML = '';
  for (let i=0;i<5;i++){
    const row = el('div', {class:'answer-row', id:`ans-${i}`},
      el('div', {}, `${i+1}. —`),
      el('div', {}, `—%`)
    );
    roundList.appendChild(row);
  }

  // UI umschalten: Brett aus, Rundenansicht an
  hide('viewBoard');
  show('viewRound');
}

function hideRoundView(){
  activeRound = null;
  hide('viewRound');
  show('viewBoard');
}

// State-Updates
socket.on('board:init', (b)=>{ renderBoard(b); hideRoundView(); });
socket.on('state:update', data => {
  renderBoard(data.board);
  renderPlayers(data.players);

  // Falls wir eine Runde anzeigen, aber Feld ist bereits beendet → zurück ins Brett
  if (activeRound){
    const it = data.board.categories?.[activeRound.ci]?.items?.[activeRound.ii];
    if (!it || it.answered){
      hideRoundView();
    }
  }
});

// Globaler Start-Zug (nach Auslosung oder „Nächste Runde“)
socket.on('turn:global', (p) => {
  updateTurnBanner(p.team, 'Wählt ein Feld.');
  hideRoundView();
});

// Turnover innerhalb der Runde (Ansicht bleibt)
socket.on('turn:changed', (p) => {
  updateTurnBanner(p.turnTeam, 'Euer Zug!');
});

// Feld gestartet → komplette Rundenansicht zeigen (kein Popup)
// NEU: Select/Lock-in-Sound abspielen, sobald ein Feld gewählt/gestartet wurde
socket.on('tile:revealed', p => {
  const sel = document.getElementById('sfxSelect');
  if (sel) sel.play().catch(()=>{});
  showRoundView(p);
  showToast(`Feld gestartet: Feld ${p.points} – Team ${p.turnTeam} beginnt`, 2500);
});

// Antwort wurde (vom Admin) aufgedeckt → Slot füllen
socket.on('answer:revealed', p => {
  if (!activeRound || activeRound.ci!==p.catIndex || activeRound.ii!==p.itemIndex) return;
  document.getElementById('sfxCorrect').play().catch(()=>{});
  const row = document.getElementById(`ans-${p.index}`);
  if (!row) return;
  row.classList.add('revealed');
  row.firstChild.textContent = `${p.index+1}. ${p.text}`;
  row.lastChild.textContent  = `${p.percent}%`;
});

// Falschantwort-Sound
socket.on('guess:wrong', () => {
  document.getElementById('sfxWrong').play().catch(()=>{});
});

// Hinweis ans wartende Team: beraten (non-blocking)
socket.on('team:prepare', () => {
  showToast('Ihr dürft euch beraten! Gleich seid ihr am Zug.', 5000);
});

// Feld beendet → zurück zum Brett (Feld erscheint dort als „used“)
socket.on('tile:closed', p => {
  hideRoundView();
  const name = p.winnerTeam === 'A' ? 'Team Rot' : 'Team Blau';
  showToast(`Feld beendet – Punkte an ${name}`, 2500);
});

// Gewinner-Animation (vom Admin ausgelöst)
socket.on('celebrate:winner', ({ team }) => {
  const t = (team === 'A' || team === 'B') ? team : 'A';
  celebrate(t);
});

// Team-Chat
const chatLog = document.getElementById('chatLog');
const chatIn  = document.getElementById('chatIn');
document.getElementById('chatBtn').onclick = () => {
  const msg = chatIn.value.trim(); if (!msg) return;
  socket.emit('chat:team', { msg });
  chatIn.value = '';
};
socket.on('chat:team', m => {
  const row = el('div', {class:'player ' + (m.from.team==='A'?'teamA':'teamB')},
    el('div', {}, `${m.from.name}:`),
    el('div', {}, m.msg)
  );
  chatLog.appendChild(row);
  chatLog.scrollTop = chatLog.scrollHeight;
});
</script>
</body>
</html>
